<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The `wasm-bindgen` Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li><a href="basic-usage.html"><strong aria-hidden="true">1.</strong> Basic Usage</a></li><li><a href="what-just-happened.html"><strong aria-hidden="true">2.</strong> What Just Happened?</a></li><li><a href="what-else-can-we-do.html"><strong aria-hidden="true">3.</strong> What Else Can We Do?</a></li><li><a href="closures.html"><strong aria-hidden="true">4.</strong> Closures</a></li><li><a href="feature-reference.html"><strong aria-hidden="true">5.</strong> Feature Reference</a></li><li><a href="cli-reference.html"><strong aria-hidden="true">6.</strong> CLI Reference</a></li><li><a href="reference.html"><strong aria-hidden="true">7.</strong> Type Reference</a></li><li class="spacer"></li><li><a href="contributing.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li><ol class="section"><li><a href="design.html"><strong aria-hidden="true">9.1.</strong> Internal Design</a></li><li><ol class="section"><li><a href="design/js-objects-in-rust.html"><strong aria-hidden="true">9.1.1.</strong> JS Objects in Rust</a></li><li><a href="design/exporting-rust.html"><strong aria-hidden="true">9.1.2.</strong> Exporting a function to JS</a></li><li><a href="design/exporting-rust-struct.html"><strong aria-hidden="true">9.1.3.</strong> Exporting a struct to JS</a></li><li><a href="design/export-customization.html"><strong aria-hidden="true">9.1.4.</strong> Customizing exports</a></li><li><a href="design/importing-js.html"><strong aria-hidden="true">9.1.5.</strong> Importing a function from JS</a></li><li><a href="design/importing-js-struct.html"><strong aria-hidden="true">9.1.6.</strong> Importing a class from JS</a></li><li><a href="design/import-customization.html"><strong aria-hidden="true">9.1.7.</strong> Customizing imports</a></li><li><a href="design/rust-type-conversions.html"><strong aria-hidden="true">9.1.8.</strong> Rust Type conversions</a></li><li><a href="design/describe.html"><strong aria-hidden="true">9.1.9.</strong> Types in wasm-bindgen</a></li></ol></li><li><a href="web-sys.html"><strong aria-hidden="true">9.2.</strong> web-sys</a></li><li><ol class="section"><li><a href="web-sys/overview.html"><strong aria-hidden="true">9.2.1.</strong> Overview</a></li><li><a href="web-sys/testing.html"><strong aria-hidden="true">9.2.2.</strong> Testing</a></li><li><a href="web-sys/logging.html"><strong aria-hidden="true">9.2.3.</strong> Logging</a></li><li><a href="web-sys/supporting-more-web-apis.html"><strong aria-hidden="true">9.2.4.</strong> Supporting More Web APIs</a></li></ol></li><li><a href="team.html"><strong aria-hidden="true">9.3.</strong> Team</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The `wasm-bindgen` Guide</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p><code>wasm-bindgen</code> facilitates high-level interactions between wasm modules and
JavaScript.</p>
<p>This project is sort of half polyfill for features like the <a href="https://github.com/WebAssembly/host-bindings">host bindings
proposal</a> and half features for empowering high-level interactions between
JS and wasm-compiled code (currently mostly from Rust). More specifically this
project allows JS/wasm to communicate with strings, JS objects, classes, etc, as
opposed to purely integers and floats. Using <code>wasm-bindgen</code> for example you can
define a JS class in Rust or take a string from JS or return one. The
functionality is growing as well!</p>
<p>Currently this tool is Rust-focused but the underlying foundation is
language-independent, and it's hoping that over time as this tool stabilizes
that it can be used for languages like C/C++!</p>
<p>Notable features of this project includes:</p>
<ul>
<li>Importing JS functionality in to Rust such as <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/dom">DOM manipulation</a>,
<a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/console_log">console logging</a>, or <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/performance">performance monitoring</a>.</li>
<li><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/smorgasboard">Exporting Rust functionality</a> to JS such as classes, functions, etc.</li>
<li>Working with rich types like strings, numbers, classes, closures, and objects
rather than simply <code>u32</code> and floats.</li>
</ul>
<p>This project is still relatively new but feedback is of course always
welcome! If you're curious about the design plus even more information about
what this crate can do, check out the <a href="https://rustwasm.github.io/wasm-bindgen/design.html">design doc</a>.</p>
<a class="header" href="print.html#basic-usage" id="basic-usage"><h1>Basic Usage</h1></a>
<p>Let's implement the equivalent of &quot;Hello, world!&quot; for this crate.</p>
<blockquote>
<p><strong>Note:</strong> Currently this projects uses <em>nightly Rust</em> which you can acquire
through <a href="https://rustup.rs">rustup</a> and configure with <code>rustup default nightly</code></p>
</blockquote>
<p>If you'd like you dive <a href="https://webassembly.studio/?f=gzubao6tg3">straight into an online example</a>, but
if you'd prefer to follow along in your own console let's install the tools we
need:</p>
<pre><code class="language-shell">$ rustup target add wasm32-unknown-unknown
$ cargo +nightly install wasm-bindgen-cli
</code></pre>
<p>The first command here installs the wasm target so you can compile to it, and
the latter will install the <code>wasm-bindgen</code> CLI tool we'll be using later.</p>
<p>Next up let's make our project</p>
<pre><code class="language-shell">$ cargo +nightly new js-hello-world --lib
</code></pre>
<p>Now let's add a dependency on this project inside <code>Cargo.toml</code> as well as
configuring our build output:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>Next up our actual code! We'll write this in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">#![feature(proc_macro, wasm_custom_section, wasm_import_module)]

extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
</code></pre>
<p>And that's it! If we were to write the <code>greet</code> function naively without the
<code>#[wasm_bindgen]</code> attribute then JS wouldn't be able to communicate with the
types like <code>str</code>, so slapping a <code>#[wasm_bindgen]</code> on the function and the import
of <code>alert</code> ensures that the right shims are generated.</p>
<p>Next up let's build our project:</p>
<pre><code class="language-shell">$ cargo +nightly build --target wasm32-unknown-unknown
</code></pre>
<p>After this you'll have a wasm file at
<code>target/wasm32-unknown-unknown/debug/js_hello_world.wasm</code>. Don't be alarmed at
the size, this is an unoptimized program!</p>
<p>Now that we've generated the wasm module it's time to run the bindgen tool
itself! This tool will postprocess the wasm file rustc generated, generating a
new wasm file and a set of JS bindings as well. Let's invoke it!</p>
<pre><code class="language-shell">$ wasm-bindgen target/wasm32-unknown-unknown/debug/js_hello_world.wasm \
  --out-dir .
</code></pre>
<p>This is the main point where the magic happens. The <code>js_hello_world.wasm</code> file
emitted by rustc contains <em>descriptors</em> of how to communicate via richer types
than wasm currently supports. The <code>wasm-bindgen</code> tool will interpret this
information, emitting a <strong>replacement module</strong> for the wasm file.</p>
<p>The previous <code>js_hello_world.wasm</code> file is interpreted as if it were an ES6
module. The <code>js_hello_world.js</code> file emitted by <code>wasm-bindgen</code> should have the
intended interface of the wasm file, notably with rich types like strings,
classes, etc.</p>
<p>The <code>wasm-bindgen</code> tool also emits a few other files needed to implement this
module. For example <code>js_hello_world_bg.wasm</code> is the original wasm file but
postprocessed a bit. It's intended that the <code>js_hello_world_bg.wasm</code> file,
like before, acts like an ES6 module.</p>
<p>At this point you'll probably plug these files into a larger build system.
Files emitted by <code>wasm-bindgen</code> act like normal ES6 modules (one just happens to
be wasm). As of the time of this writing there's unfortunately not a lot of
tools that natively do this, but Webpack's 4.0 beta release has native wasm
support!. Let's take a look at that and see how it works.</p>
<p>First create an <code>index.js</code> file:</p>
<pre><code class="language-js">const js = import(&quot;./js_hello_world&quot;);

js.then(js =&gt; {
  js.greet(&quot;World!&quot;);
});
</code></pre>
<p>Note that we're using <code>import(..)</code> here because Webpack <a href="https://github.com/webpack/webpack/issues/6615">doesn't
support</a> synchronously importing modules from the main chunk just
yet.</p>
<p>Next our JS dependencies by creating a <code>package.json</code>:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.0.1&quot;,
    &quot;webpack-cli&quot;: &quot;^2.0.10&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.0&quot;
  }
}
</code></pre>
<p>and our webpack configuration</p>
<pre><code class="language-js">// webpack.config.js
const path = require('path');

module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
  mode: &quot;development&quot;
};
</code></pre>
<p>Our corresponding <code>index.html</code>:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta content=&quot;text/html;charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src='./index.js'&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>And finally:</p>
<pre><code class="language-shell">$ npm install
$ npm run serve
</code></pre>
<p>If you open <a href="http://localhost:8080">http://localhost:8080</a> in a browser you should see a <code>Hello, world!</code>
dialog pop up!</p>
<p>If that was all a bit much, no worries! You can <a href="https://webassembly.studio/?f=gzubao6tg3">execute this code
online</a> thanks to <a href="https://webassembly.studio">WebAssembly Studio</a>
or you can <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/hello_world">follow along on GitHub</a> to see all the files necessary
as well as a script to set it all up.</p>
<a class="header" href="print.html#what-just-happened" id="what-just-happened"><h1>What Just Happened?</h1></a>
<p>Phew! That was a lot of words and a lot ended up happening along the way. There
were two main pieces of magic happening: the <code>#[wasm_bindgen]</code> attribute and the
<code>wasm-bindgen</code> CLI tool.</p>
<p><strong>The <code>#[wasm_bindgen]</code> attribute</strong></p>
<p>This attribute, exported from the <code>wasm-bindgen</code> crate, is the entrypoint to
exposing Rust functions to JS. This is a procedural macro (hence requiring the
nightly Rust toolchain) which will generate the appropriate shims in Rust to
translate from your type signature to one that JS can interface with. Finally
the attribute also serializes some information to the output artifact which
<code>wasm-bindgen</code>-the-tool will discard after it parses.</p>
<p>There's a more thorough explanation below of the various bits and pieces of the
attribute, but it suffices for now to say that you can attach it to free
functions, structs, impl blocks for those structs and <code>extern { ... }</code> blocks.
Some Rust features like generics, lifetime parameters, etc, aren't supported on
functions tagged with <code>#[wasm_bindgen]</code> right now.</p>
<p><strong>The <code>wasm-bindgen</code> CLI tool</strong></p>
<p>The next half of what happened here was all in the <code>wasm-bindgen</code> tool. This
tool opened up the wasm module that rustc generated and found an encoded
description of what was passed to the <code>#[wasm_bindgen]</code> attribute. You can
think of this as the <code>#[wasm_bindgen]</code> attribute created a special section of
the output module which <code>wasm-bindgen</code> strips and processes.</p>
<p>This information gave <code>wasm-bindgen</code> all it needed to know to generate the JS
file that we then imported. The JS file wraps instantiating the underlying wasm
module (aka calling <code>WebAssembly.instantiate</code>) and then provides wrappers for
classes/functions within.</p>
<a class="header" href="print.html#what-else-can-we-do" id="what-else-can-we-do"><h1>What Else Can We Do?</h1></a>
<p>Much more! Here's a taste of various features you can use in this project. You
can also <a href="https://webassembly.studio/?f=t61j18noqz">explore this code online</a>:</p>
<pre><code class="language-rust ignore">// src/lib.rs
#![feature(proc_macro, wasm_custom_section, wasm_import_module)]

extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

// Strings can both be passed in and received
#[wasm_bindgen]
pub fn concat(a: &amp;str, b: &amp;str) -&gt; String {
    let mut a = a.to_string();
    a.push_str(b);
    return a
}

// A struct will show up as a class on the JS side of things
#[wasm_bindgen]
pub struct Foo {
    contents: u32,
}

#[wasm_bindgen]
impl Foo {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; Foo {
        Foo { contents: 0 }
    }

    // Methods can be defined with `&amp;mut self` or `&amp;self`, and arguments you
    // can pass to a normal free function also all work in methods.
    pub fn add(&amp;mut self, amt: u32) -&gt; u32 {
        self.contents += amt;
        return self.contents
    }

    // You can also take a limited set of references to other types as well.
    pub fn add_other(&amp;mut self, bar: &amp;Bar) {
        self.contents += bar.contents;
    }

    // Ownership can work too!
    pub fn consume_other(&amp;mut self, bar: Bar) {
        self.contents += bar.contents;
    }
}

#[wasm_bindgen]
pub struct Bar {
    contents: u32,
    opaque: JsValue, // defined in `wasm_bindgen`, imported via prelude
}

#[wasm_bindgen(module = &quot;./index&quot;)] // what ES6 module to import from
extern {
    fn bar_on_reset(to: &amp;str, opaque: &amp;JsValue);

    // We can import classes and annotate functionality on those classes as well
    type Awesome;
    #[wasm_bindgen(constructor)]
    fn new() -&gt; Awesome;
    #[wasm_bindgen(method)]
    fn get_internal(this: &amp;Awesome) -&gt; u32;
}

#[wasm_bindgen]
impl Bar {
    pub fn from_str(s: &amp;str, opaque: JsValue) -&gt; Bar {
        let contents = s.parse().unwrap_or_else(|_| {
            Awesome::new().get_internal()
        });
        Bar { contents, opaque }
    }

    pub fn reset(&amp;mut self, s: &amp;str) {
        if let Ok(n) = s.parse() {
            bar_on_reset(s, &amp;self.opaque);
            self.contents = n;
        }
    }
}
</code></pre>
<p>The generated JS bindings for this invocation of the macro <a href="https://gist.github.com/alexcrichton/3d85c505e785fb8ff32e2c1cf9618367">look like
this</a>. You can view them in action like so:</p>
<p>and our corresponding <code>index.js</code>:</p>
<pre><code class="language-js">import { Foo, Bar, concat } from &quot;./js_hello_world&quot;;
import { booted } from &quot;./js_hello_world_wasm&quot;;

export function bar_on_reset(s, token) {
  console.log(token);
  console.log(`this instance of bar was reset to ${s}`);
}

function assertEq(a, b) {
  if (a !== b)
    throw new Error(`${a} != ${b}`);
  console.log(`found ${a} === ${b}`);
}

function main() {
  assertEq(concat('a', 'b'), 'ab');

  // Note that to use `new Foo()` the constructor function must be annotated
  // with `#[wasm_bindgen(constructor)]`, otherwise only `Foo.new()` can be used.
  // Additionally objects allocated corresponding to Rust structs will need to
  // be deallocated on the Rust side of things with an explicit call to `free`.
  let foo = new Foo();
  assertEq(foo.add(10), 10);
  foo.free();

  // Pass objects to one another
  let foo1 = new Foo();
  let bar = Bar.from_str(&quot;22&quot;, { opaque: 'object' });
  foo1.add_other(bar);

  // We also don't have to `free` the `bar` variable as this function is
  // transferring ownership to `foo1`
  bar.reset('34');
  foo1.consume_other(bar);

  assertEq(foo1.add(2), 22 + 34 + 2);
  foo1.free();

  alert('all passed!')
}

export class Awesome {
  constructor() {
    this.internal = 32;
  }

  get_internal() {
    return this.internal;
  }
}

booted.then(main);
</code></pre>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<p>The <code>#[wasm_bindgen]</code> attribute supports some Rust closures being passed to JS.
Examples of what you can do are:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn foo(a: &amp;Fn()); // could also be `&amp;mut FnMut()`
}
#}</code></pre></pre>
<p>Here a function <code>foo</code> is imported from JS where the first argument is a <em>stack
closure</em>. You can call this function with a <code>&amp;Fn()</code> argument and JS will receive
a JS function. When the <code>foo</code> function returns, however, the JS function will be
invalidated and any future usage of it will raise an exception.</p>
<p>Closures also support arguments and return values like exports do, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;

    fn bar(a: &amp;Fn(u32, String) -&gt; Foo);
}
#}</code></pre></pre>
<p>Sometimes the stack behavior of these closures is not desired. For example you'd
like to schedule a closure to be run on the next turn of the event loop in JS
through <code>setTimeout</code>. For this you want the imported function to return but the
JS closure still needs to be valid!</p>
<p>To support this use case you can do:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn baz(a: &amp;Closure&lt;Fn()&gt;);
}
#}</code></pre></pre>
<p>The <code>Closure</code> type is defined in the <code>wasm_bindgen</code> crate and represents a &quot;long
lived&quot; closure. The JS closure passed to <code>baz</code> is still valid after <code>baz</code>
returns, and the validity of the JS closure is tied to the lifetime of the
<code>Closure</code> in Rust. Once <code>Closure</code> is dropped it will deallocate its internal
memory and invalidate the corresponding JS function.</p>
<p>Like stack closures a <code>Closure</code> also supports <code>FnMut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn another(a: &amp;Closure&lt;FnMut() -&gt; u32&gt;);
}
#}</code></pre></pre>
<p>At this time you cannot <a href="https://github.com/rustwasm/wasm-bindgen/issues/103">pass a JS closure to Rust</a>, you can only pass a
Rust closure to JS in limited circumstances.</p>
<a class="header" href="print.html#feature-reference" id="feature-reference"><h1>Feature Reference</h1></a>
<p>Here this section will attempt to be a reference for the various features
implemented in this project. This is likely not exhaustive but the <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/tests">tests</a>
should also be a great place to look for examples.</p>
<p>The <code>#[wasm_bindgen]</code> attribute can be attached to functions, structs,
impls, and foreign modules. Impls can only contain functions, and the attribute
cannot be attached to functions in an impl block or functions in a foreign
module. No lifetime parameters or type parameters are allowed on any of these
types. Foreign modules must have the <code>&quot;C&quot;</code> abi (or none listed). Free functions
with <code>#[wasm_bindgen]</code> might not have the <code>&quot;C&quot;</code> abi or none listed, and it's also not
necessary to annotate with the <code>#[no_mangle]</code> attribute.</p>
<p>All structs referenced through arguments to functions should be defined in the
macro itself. Arguments allowed implement the <code>WasmBoundary</code> trait, and examples
are:</p>
<ul>
<li>Integers (u64/i64 require <code>BigInt</code> support)</li>
<li>Floats</li>
<li>Borrowed strings (<code>&amp;str</code>)</li>
<li>Owned strings (<code>String</code>)</li>
<li>Exported structs (<code>Foo</code>, annotated with <code>#[wasm_bindgen]</code>)</li>
<li>Exported C-like enums (<code>Foo</code>, annotated with <code>#[wasm_bindgen]</code>)</li>
<li>Imported types in a foreign module annotated with <code>#[wasm_bindgen]</code></li>
<li>Borrowed exported structs (<code>&amp;Foo</code> or <code>&amp;mut Bar</code>)</li>
<li>The <code>JsValue</code> type and <code>&amp;JsValue</code> (not mutable references)</li>
<li>Vectors and slices of supported integer types and of the <code>JsValue</code> type.</li>
</ul>
<p>All of the above can also be returned except borrowed references. Passing
<code>Vec&lt;JsValue&gt;</code> as an argument to a function is not currently supported. Strings are
implemented with shim functions to copy data in/out of the Rust heap. That is, a
string passed to Rust from JS is copied to the Rust heap (using a generated shim
to malloc some space) and then will be freed appropriately.</p>
<p>Owned values are implemented through boxes. When you return a <code>Foo</code> it's
actually turned into <code>Box&lt;RefCell&lt;Foo&gt;&gt;</code> under the hood and returned to JS as a
pointer. The pointer is to have a defined ABI, and the <code>RefCell</code> is to ensure
safety with reentrancy and aliasing in JS. In general you shouldn't see
<code>RefCell</code> panics with normal usage.</p>
<p>JS-values-in-Rust are implemented through indexes that index a table generated
as part of the JS bindings. This table is managed via the ownership specified in
Rust and through the bindings that we're returning. More information about this
can be found in the [design doc].</p>
<p>All of these constructs currently create relatively straightforward code on the
JS side of things, mostly having a 1:1 match in Rust with JS.</p>
<a class="header" href="print.html#cli-reference" id="cli-reference"><h1>CLI Reference</h1></a>
<p>The <code>wasm-bindgen</code> tool has a number of options available to it to tweak the JS
that is generated. By default the generated JS uses ES modules and is compatible
with both Node and browsers (but will likely require a bundler for both use
cases).</p>
<p>Supported flags of the CLI tool can be learned via <code>wasm-bindgen --help</code>, but
some notable options are:</p>
<ul>
<li>
<p><code>--nodejs</code>: this flag will tailor output for Node instead of browsers,
allowing for native usage of <code>require</code> of the generated JS and internally
using <code>require</code> instead of ES modules. When using this flag no further
postprocessing (aka a bundler) should be necessary to work with the wasm.</p>
</li>
<li>
<p><code>--browser</code>: this flag will tailor the output specifically for browsers,
making it incompatible with Node. This will basically make the generated JS a
tiny bit smaller as runtime checks for Node won't be necessary.</p>
</li>
<li>
<p><code>--no-modules</code>: the default output of <code>wasm-bindgen</code> uses ES modules but this
option indicates that ES modules should not be used and output should be
tailored for a web browser. In this mode <code>window.wasm_bindgen</code> will be a
function that takes a path to the wasm file to fetch and instantiate.
Afterwards exported functions from the wasm are available through
<code>window.wasm_bindgen.foo</code>. Note that the name <code>wasm_bindgen</code> can be configured
with the <code>--no-modules-global FOO</code> flag.</p>
</li>
<li>
<p><code>--no-typescript</code>: by default a <code>*.d.ts</code> file is generated for the generated
JS file, but this flag will disable generating this TypeScript file.</p>
</li>
<li>
<p><code>--debug</code>: generates a bit more JS and wasm in &quot;debug mode&quot; to help catch
programmer errors, but this output isn't intended to be shipped to production</p>
</li>
</ul>
<a class="header" href="print.html#reference" id="reference"><h1>Reference</h1></a>
<p>The table below provides an overview of all the types that wasm-bindgen can send/receive across the wasm ABI boundary.</p>
<table><thead><tr><th align="center"> Type </th><th align="center"> <code>T</code> parameter </th><th align="center"> <code>&amp;T</code> parameter </th><th align="center"> <code>&amp;mut T</code> parameter </th><th align="center"> <code>T</code> return value </th></tr></thead><tbody>
<tr><td align="center"> <code>str</code> </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>char</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>bool</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>JsValue</code> </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>Box&lt;[JsValue]&gt;</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>*const T</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>*mut T</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>u8</code> <code>i8</code> <code>u16</code> <code>i16</code> <code>u64</code> <code>i64</code> <code>isize</code> <code>size</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>u32</code> <code>i32</code> <code>f32</code> <code>f64</code> </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>Box&lt;[u8]&gt;</code>  <code>Box&lt;[i8]&gt;</code> <code>Box&lt;[u16]&gt;</code> <code>Box&lt;[i16]&gt;</code> <code>Box&lt;[u32]&gt;</code> <code>Box&lt;[i32]&gt;</code> <code>Box&lt;[u64]&gt;</code> <code>Box&lt;[i64]&gt;</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>Box&lt;[f32]&gt;</code> <code>Box&lt;[f64]&gt;</code> </td><td align="center"> Yes </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>[u8]</code> <code>[i8]</code> <code>[u16]</code> <code>[i16]</code> <code>[u32]</code> <code>[i32]</code> <code>[u64]</code> <code>[i64]</code> </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td></tr>
<tr><td align="center"> <code>&amp;[u8]</code> <code>&amp;mut[u8]</code> <code>&amp;[i8]</code>  <code>&amp;mut[i8]</code> <code>&amp;[u16]</code> <code>&amp;mut[u16]</code> <code>&amp;[i16]</code> <code>&amp;mut[i16]</code> <code>&amp;[u32]</code> <code>&amp;mut[u32]</code> <code>&amp;[i32]</code> <code>&amp;mut[i32]</code> <code>&amp;[u64]</code> <code>&amp;mut[u64]</code> <code>&amp;[i64]</code> <code>&amp;mut[i64]</code> </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
<tr><td align="center"> <code>[f32]</code> <code>[f64]</code> </td><td align="center"> No </td><td align="center"> Yes </td><td align="center"> Yes </td><td align="center"> No </td></tr>
<tr><td align="center">  <code>&amp;[f32]</code> <code>&amp;mut[f32]</code> <code>&amp;[f64]</code> <code>&amp;mut[f64]</code> </td><td align="center"> No </td><td align="center"> No </td><td align="center"> No </td><td align="center"> Yes </td></tr>
</tbody></table>
<a class="header" href="print.html#contributing-to-wasm-bindgen" id="contributing-to-wasm-bindgen"><h1>Contributing to <code>wasm-bindgen</code></h1></a>
<p>This section contains instructions on how to get this project up and running for
development.</p>
<a class="header" href="print.html#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<ol>
<li>
<p>Rust Nightly. <a href="https://www.rust-lang.org/en-US/install.html">Install Rust</a>. Once Rust is installed, run</p>
<pre><code class="language-shell">rustup default nightly
rustup target add wasm32-unknown-unknown
</code></pre>
</li>
</ol>
<ol start="2">
<li>The tests for this project use Node. Make sure you have node &gt;= 8 installed,
as that is when WebAssembly support was introduced. <a href="https://nodejs.org/en/">Install Node</a>.</li>
</ol>
<ol start="3">
<li>
<p>The tests for this project also use <code>yarn</code>, a package manager for Node. To
install <code>yarn</code>, run:</p>
<pre><code class="language-shell">npm install -g yarn
</code></pre>
<p>or follow other platform-specific instructions
<a href="https://yarnpkg.com/en/docs/install">here</a>.</p>
<p>Once <code>yarn</code> is installed, run it in the top level directory:</p>
<pre><code class="language-shell">yarn
</code></pre>
</li>
</ol>
<a class="header" href="print.html#running-tests" id="running-tests"><h2>Running Tests</h2></a>
<p>Finally, you can run the tests with <code>cargo</code>:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<a class="header" href="print.html#headless-browser-tests" id="headless-browser-tests"><h3>Headless Browser Tests</h3></a>
<p>Some tests are configured to run in a headless Firefox instance. To run these
tests, you must have Firefox installed. If you have Firefox installed in a
non-default, custom location you can set the <code>WASM_BINDGEN_FIREFOX_BIN_PATH</code>
environment variable to the path to your <code>firefox-bin</code>.</p>
<p>For example:</p>
<pre><code class="language-shell">WASM_BINDGEN_FIREFOX_BIN_PATH=/home/fitzgen/firefox/firefox-bin cargo test
</code></pre>
<a class="header" href="print.html#design-of-wasm-bindgen" id="design-of-wasm-bindgen"><h1>Design of <code>wasm-bindgen</code></h1></a>
<p>This section is intended to be a deep-dive into how <code>wasm-bindgen</code> internally
works today, specifically for Rust. If you're reading this far in the future it
may no longer be up to date, but feel free to open an issue and we can try to
answer questions and/or update this!</p>
<a class="header" href="print.html#foundation-es-modules" id="foundation-es-modules"><h2>Foundation: ES Modules</h2></a>
<p>The first thing to know about <code>wasm-bindgen</code> is that it's fundamentally built on
the idea of ES Modules. In other words this tool takes an opinionated stance
that wasm files <em>should be viewed as ES modules</em>. This means that you can
<code>import</code> from a wasm file, use its <code>export</code>-ed functionality, etc, from normal
JS files.</p>
<p>Now unfortunately at the time of this writing the interface of wasm interop
isn't very rich. Wasm modules can only call functions or export functions that
deal exclusively with <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code>. Bummer!</p>
<p>That's where this project comes in. The goal of <code>wasm-bindgen</code> is to enhance the
&quot;ABI&quot; of wasm modules with richer types like classes, JS objects, Rust structs,
strings, etc. Keep in mind, though, that everything is based on ES Modules! This
means that the compiler is actually producing a &quot;broken&quot; wasm file of sorts. The
wasm file emitted by rustc, for example, does not have the interface we would
like to have. Instead it requires the <code>wasm-bindgen</code> tool to postprocess the
file, generating a <code>foo.js</code> and <code>foo_bg.wasm</code> file. The <code>foo.js</code> file is the
desired interface expressed in JS (classes, types, strings, etc) and the
<code>foo_bg.wasm</code> module is simply used as an implementation detail (it was
lightly modified from the original <code>foo.wasm</code> file).</p>
<p>As more features are stabilized in WebAssembly over time (like host bindings)
the JS file is expected to get smaller and smaller. It's unlikely to ever
disappear, but <code>wasm-bindgen</code> is designed to follow the WebAssembly spec and
proposals closely to optimize JS/Rust as much as possible.</p>
<a class="header" href="print.html#foundation-2-unintrusive-in-rust" id="foundation-2-unintrusive-in-rust"><h2>Foundation #2: Unintrusive in Rust</h2></a>
<p>On the more Rust-y side of things the <code>wasm-bindgen</code> crate is designed to
ideally have as minimal impact on a Rust crate as possible. Ideally a few
<code>#[wasm_bindgen]</code> attributes are annotated in key locations and otherwise you're
off to the races. The attribute strives to both not invent new syntax and work
with existing idioms today.</p>
<p>For example a library might exposed a function in normal Rust that looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn greet(name: &amp;str) -&gt; String {
    // ...
}
#}</code></pre></pre>
<p>And with <code>#[wasm_bindgen]</code> all you need to do in exporting it to JS is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    // ...
}
#}</code></pre></pre>
<p>Additionally the design here with minimal intervention in Rust should allow us
to easily take advantage of the upcoming <a href="https://github.com/WebAssembly/host-bindings">host bindings</a> proposal. Ideally
you'd simply upgrade <code>wasm-bindgen</code>-the-crate as well as your toolchain and
you're immediately getting raw access to host bindings! (this is still a bit of
a ways off though...)</p>
<a class="header" href="print.html#polyfill-for-js-objects-in-wasm" id="polyfill-for-js-objects-in-wasm"><h1>Polyfill for &quot;JS objects in wasm&quot;</h1></a>
<p>One of the main goals of <code>wasm-bindgen</code> is to allow working with and passing
around JS objects in wasm, but that's not allowed today! While indeed true,
that's where the polyfill comes in.</p>
<p>The question here is how we shoehorn JS objects into a <code>u32</code> for wasm to use.
The current strategy for this approach is to maintain two module-local variables
in the generated <code>foo.js</code> file: a stack and a heap.</p>
<a class="header" href="print.html#temporary-js-objects-on-the-stack" id="temporary-js-objects-on-the-stack"><h3>Temporary JS objects on the stack</h3></a>
<p>The stack in <code>foo.js</code> is, well, a stack. JS objects are pushed on the top of the
stack, and their index in the stack is the identifier that's passed to wasm. JS
objects are then only removed from the top of the stack as well. This data
structure is mainly useful for efficiently passing a JS object into wasm without
a sort of &quot;heap allocation&quot;. The downside of this, however, is that it only
works for when wasm doesn't hold onto a JS object (aka it only gets a
&quot;reference&quot; in Rust parlance).</p>
<p>Let's take a look at an example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[wasm_bindgen]
pub fn foo(a: &amp;JsValue) {
    // ...
}
#}</code></pre></pre>
<p>Here we're using the special <code>JsValue</code> type from the <code>wasm-bindgen</code> library
itself. Our exported function, <code>foo</code>, takes a <em>reference</em> to an object. This
notably means that it can't persist the object past the lifetime of this
function call.</p>
<p>Now what we actually want to generate is a JS module that looks like (in
Typescript parlance)</p>
<pre><code class="language-ts">// foo.d.ts
export function foo(a: any);
</code></pre>
<p>and what we actually generate looks something like:</p>
<pre><code class="language-js">// foo.js
import * as wasm from './foo_bg';

const stack = [];

function addBorrowedObject(obj) {
  stack.push(obj);
  return stack.length - 1;
}

export function foo(arg0) {
  const idx0 = addBorrowedObject(arg0);
  try {
    wasm.foo(idx0);
  } finally {
    stack.pop();
  }
}
</code></pre>
<p>Here we can see a few notable points of action:</p>
<ul>
<li>The wasm file was renamed to <code>foo_bg.wasm</code>, and we can see how the JS module
generated here is importing from the wasm file.</li>
<li>Next we can see our <code>stack</code> module variable which is used to push/pop items
from the stack.</li>
<li>Our exported function <code>foo</code>, takes an arbitrary argument, <code>arg0</code>, which is
converted to an index with the <code>addBorrowedObject</code> object function. The index
is then passed to wasm so wasm can operate with it.</li>
<li>Finally, we have a <code>finally</code> which frees the stack slot as it's no longer
used, issuing a <code>pop</code> for what was pushed at the start of the function.</li>
</ul>
<p>It's also helpful to dig into the Rust side of things to see what's going on
there! Let's take a look at the code that <code>#[wasm_bindgen]</code> generates in Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// what the user wrote
pub fn foo(a: &amp;JsValue) {
    // ...
}

#[export_name = &quot;foo&quot;]
pub extern fn __wasm_bindgen_generated_foo(arg0: u32) {
    let arg0 = unsafe {
        ManuallyDrop::new(JsValue::__from_idx(arg0))
    };
    let arg0 = &amp;*arg0;
    foo(arg0);
}
#}</code></pre></pre>
<p>And as with the JS, the notable points here are:</p>
<ul>
<li>The original function, <code>foo</code>, is unmodified in the output</li>
<li>A generated function here (with a unique name) is the one that's actually
exported from the wasm module</li>
<li>Our generated function takes an integer argument (our index) and then wraps it
in a <code>JsValue</code>. There's some trickery here that's not worth going into just
yet, but we'll see in a bit what's happening under the hood.</li>
</ul>
<a class="header" href="print.html#long-lived-js-objects-in-a-slab" id="long-lived-js-objects-in-a-slab"><h3>Long-lived JS objects in a slab</h3></a>
<p>The above strategy is useful when JS objects are only temporarily used in Rust,
for example only during one function call. Sometimes, though, objects may have a
dynamic lifetime or otherwise need to be stored on Rust's heap. To cope with
this there's a second half of management of JS objects, a slab.</p>
<p>JS Objects passed to wasm that are not references are assumed to have a dynamic
lifetime inside of the wasm module. As a result the strict push/pop of the stack
won't work and we need more permanent storage for the JS objects. To cope with
this we build our own &quot;slab allocator&quot; of sorts.</p>
<p>A picture (or code) is worth a thousand words so let's show what happens with an
example.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[wasm_bindgen]
pub fn foo(a: JsValue) {
    // ...
}
#}</code></pre></pre>
<p>Note that the <code>&amp;</code> is missing in front of the <code>JsValue</code> we had before, and in
Rust parlance this means it's taking ownership of the JS value. The exported ES
module interface is the same as before, but the ownership mechanics are slightly
different. Let's see the generated JS's slab in action:</p>
<pre><code class="language-js">import * as wasm from './foo_bg'; // imports from wasm file

const slab = [];
let slab_next = 0;

function addHeapObject(obj) {
  if (slab_next === slab.length)
    slab.push(slab.length + 1);
  const idx = slab_next;
  const next = slab[idx];
  slab_next = next;
  slab[idx] = { obj, cnt: 1 };
  return idx;
}

export function foo(arg0) {
  const idx0 = addHeapObject(arg0);
  wasm.foo(idx0);
}

export function __wbindgen_object_drop_ref(idx) {
  let obj = slab[idx];
  obj.cnt -= 1;
  if (obj.cnt &gt; 0)
    return;
  // If we hit 0 then free up our space in the slab
  slab[idx] = slab_next;
  slab_next = idx;
}
</code></pre>
<p>Unlike before we're now calling <code>addHeapObject</code> on the argument to <code>foo</code> rather
than <code>addBorrowedObject</code>. This function will use <code>slab</code> and <code>slab_next</code> as a
slab allocator to acquire a slot to store the object, placing a structure there
once it's found.</p>
<p>Note here that a reference count is used in addition to storing the object.
That's so we can create multiple references to the JS object in Rust without
using <code>Rc</code>, but it's overall not too important to worry about here.</p>
<p>Another curious aspect of this generated module is the
<code>__wbindgen_object_drop_ref</code> function. This is one that's actually imported from
wasm rather than used in this module! This function is used to signal the end of
the lifetime of a <code>JsValue</code> in Rust, or in other words when it goes out of
scope. Otherwise though this function is largely just a general &quot;slab free&quot;
implementation.</p>
<p>And finally, let's take a look at the Rust generated again too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// what the user wrote
pub fn foo(a: JsValue) {
    // ...
}

#[export_name = &quot;foo&quot;]
pub extern fn __wasm_bindgen_generated_foo(arg0: u32) {
    let arg0 = unsafe {
        JsValue::__from_idx(arg0)
    };
    foo(arg0);
}
#}</code></pre></pre>
<p>Ah that looks much more familiar! Not much interesting is happening here, so
let's move on to...</p>
<a class="header" href="print.html#anatomy-of-jsvalue" id="anatomy-of-jsvalue"><h3>Anatomy of <code>JsValue</code></h3></a>
<p>Currently the <code>JsValue</code> struct is actually quite simple in Rust, it's:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct JsValue {
    idx: u32,
}

// &quot;private&quot; constructors

impl Drop for JsValue {
    fn drop(&amp;mut self) {
        unsafe {
            __wbindgen_object_drop_ref(self.idx);
        }
    }
}
#}</code></pre></pre>
<p>Or in other words it's a newtype wrapper around a <code>u32</code>, the index that we're
passed from wasm. The destructor here is where the <code>__wbindgen_object_drop_ref</code>
function is called to relinquish our reference count of the JS object, freeing
up our slot in the <code>slab</code> that we saw above.</p>
<p>If you'll recall as well, when we took <code>&amp;JsValue</code> above we generated a wrapper
of <code>ManuallyDrop</code> around the local binding, and that's because we wanted to
avoid invoking this destructor when the object comes from the stack.</p>
<a class="header" href="print.html#indexing-both-a-slab-and-the-stack" id="indexing-both-a-slab-and-the-stack"><h3>Indexing both a slab and the stack</h3></a>
<p>You might be thinking at this point that this system may not work! There's
indexes into both the slab and the stack mixed up, but how do we differentiate?
It turns out that the examples above have been simplified a bit, but otherwise
the lowest bit is currently used as an indicator of whether you're a slab or a
stack index.</p>
<a class="header" href="print.html#exporting-a-function-to-js" id="exporting-a-function-to-js"><h1>Exporting a function to JS</h1></a>
<p>Alright now that we've got a good grasp on JS objects and how they're working,
let's take a look at another feature of <code>wasm-bindgen</code>: exporting functionality
with types that are richer than just numbers.</p>
<p>The basic idea around exporting functionality with more flavorful types is that
the wasm exports won't actually be called directly. Instead the generated
<code>foo.js</code> module will have shims for all exported functions in the wasm module.</p>
<p>The most interesting conversion here happens with strings so let's take a look
at that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn greet(a: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, a)
}
#}</code></pre></pre>
<p>Here we'd like to define an ES module that looks like</p>
<pre><code class="language-ts">// foo.d.ts
export function greet(a: string): string;
</code></pre>
<p>To see what's going on, let's take a look at the generated shim</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

function passStringToWasm(arg) {
  const buf = new TextEncoder('utf-8').encode(arg);
  const len = buf.length;
  const ptr = wasm.__wbindgen_malloc(len);
  let array = new Uint8Array(wasm.memory.buffer);
  array.set(buf, ptr);
  return [ptr, len];
}

function getStringFromWasm(ptr, len) {
  const mem = new Uint8Array(wasm.memory.buffer);
  const slice = mem.slice(ptr, ptr + len);
  const ret = new TextDecoder('utf-8').decode(slice);
  return ret;
}

export function greet(arg0) {
  const [ptr0, len0] = passStringToWasm(arg0);
  try {
    const ret = wasm.greet(ptr0, len0);
    const ptr = wasm.__wbindgen_boxed_str_ptr(ret);
    const len = wasm.__wbindgen_boxed_str_len(ret);
    const realRet = getStringFromWasm(ptr, len);
    wasm.__wbindgen_boxed_str_free(ret);
    return realRet;
  } finally {
    wasm.__wbindgen_free(ptr0, len0);
  }
}
</code></pre>
<p>Phew, that's quite a lot! We can sort of see though if we look closely what's
happening:</p>
<ul>
<li>
<p>Strings are passed to wasm via two arguments, a pointer and a length. Right
now we have to copy the string onto the wasm heap which means we'll be using
<code>TextEncoder</code> to actually do the encoding. Once this is done we use an
internal function in <code>wasm-bindgen</code> to allocate space for the string to go,
and then we'll pass that ptr/length to wasm later on.</p>
</li>
<li>
<p>Returning strings from wasm is a little tricky as we need to return a ptr/len
pair, but wasm currently only supports one return value (multiple return values
<a href="https://github.com/WebAssembly/design/issues/1146">is being standardized</a>).
To work around this in the meantime, we're actually returning a pointer to a
ptr/len pair, and then using functions to access the various fields.</p>
</li>
<li>
<p>Some cleanup ends up happening in wasm. The <code>__wbindgen_boxed_str_free</code>
function is used to free the return value of <code>greet</code> after it's been decoded
onto the JS heap (using <code>TextDecoder</code>). The <code>__wbindgen_free</code> is then used to
free the space we allocated to pass the string argument once the function call
is done.</p>
</li>
</ul>
<p>Next let's take a look at the Rust side of things as well. Here we'll be looking
at a mostly abbreviated and/or &quot;simplified&quot; in the sense of this is what it
compiles down to:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub extern fn greet(a: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, a)
}

#[export_name = &quot;greet&quot;]
pub extern fn __wasm_bindgen_generated_greet(
    arg0_ptr: *const u8,
    arg0_len: usize,
) -&gt; *mut String {
    let arg0 = unsafe {
        let slice = ::std::slice::from_raw_parts(arg0_ptr, arg0_len);
        ::std::str::from_utf8_unchecked(slice)
    };
    let _ret = greet(arg0);
    Box::into_raw(Box::new(_ret))
}
#}</code></pre></pre>
<p>Here we can see again that our <code>greet</code> function is unmodified and has a wrapper
to call it. This wrapper will take the ptr/len argument and convert it to a
string slice, while the return value is boxed up into just a pointer and is
then returned up to was for reading via the <code>__wbindgen_boxed_str_*</code> functions.</p>
<p>So in general exporting a function involves a shim both in JS and in Rust with
each side translating to or from wasm arguments to the native types of each
language. The <code>wasm-bindgen</code> tool manages hooking up all these shims while the
<code>#[wasm_bindgen]</code> macro takes care of the Rust shim as well.</p>
<p>Most arguments have a relatively clear way to convert them, bit if you've got
any questions just let me know!</p>
<a class="header" href="print.html#exporting-a-struct-to-js" id="exporting-a-struct-to-js"><h1>Exporting a struct to JS</h1></a>
<p>So far we've covered JS objects, importing functions, and exporting functions.
This has given us quite a rich base to build on so far, and that's great! We
sometimes, though, want to go even further and define a JS <code>class</code> in Rust. Or
in other words, we want to expose an object with methods from Rust to JS rather
than just importing/exporting free functions.</p>
<p>The <code>#[wasm_bindgen]</code> attribute can annotate both a <code>struct</code> and <code>impl</code> blocks
to allow:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Foo {
    internal: i32,
}

#[wasm_bindgen]
impl Foo {
    pub fn new(val: i32) -&gt; Foo {
        Foo { internal: val }
    }

    pub fn get(&amp;self) -&gt; i32 {
        self.internal
    }

    pub fn set(&amp;mut self, val: i32) {
        self.internal = val;
    }
}
#}</code></pre></pre>
<p>This is a typical Rust <code>struct</code> definition for a type with a constructor and a
few methods. Annotating the struct with <code>#[wasm_bindgen]</code> means that we'll
generate necessary trait impls to convert this type to/from the JS boundary. The
annotated <code>impl</code> block here means that the functions inside will also be made
available to JS through generated shims. If we take a look at the generated JS
code for this we'll see:</p>
<pre><code class="language-js">import * as wasm from './js_hello_world_bg';

export class Foo {
    static __construct(ptr) {
        return new Foo(ptr);
    }

    constructor(ptr) {
        this.ptr = ptr;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;
        wasm.__wbg_foo_free(ptr);
    }

    static new(arg0) {
        const ret = wasm.foo_new(arg0);
        return Foo.__construct(ret)
    }

    get() {
        const ret = wasm.foo_get(this.ptr);
        return ret;
    }

    set(arg0) {
        const ret = wasm.foo_set(this.ptr, arg0);
        return ret;
    }
}
</code></pre>
<p>That's actually not much! We can see here though how we've translated from Rust
to JS:</p>
<ul>
<li>Associated functions in Rust (those without <code>self</code>) turn into <code>static</code>
functions in JS.</li>
<li>Methods in Rust turn into methods in wasm.</li>
<li>Manual memory management is exposed in JS as well. The <code>free</code> function is
required to be invoked to deallocate resources on the Rust side of things.</li>
</ul>
<p>To be able to use <code>new Foo()</code>, you'd need to annotate <code>new</code> as <code>#[wasm_bindgen(constructor)]</code>.</p>
<p>One important aspect to note here, though, is that once <code>free</code> is called the JS
object is &quot;neutered&quot; in that its internal pointer is nulled out. This means that
future usage of this object should trigger a panic in Rust.</p>
<p>The real trickery with these bindings ends up happening in Rust, however, so
let's take a look at that.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// original input to `#[wasm_bindgen]` omitted ...

#[export_name = &quot;foo_new&quot;]
pub extern fn __wasm_bindgen_generated_Foo_new(arg0: i32) -&gt; u32
    let ret = Foo::new(arg0);
    Box::into_raw(Box::new(WasmRefCell::new(ret))) as u32
}

#[export_name = &quot;foo_get&quot;]
pub extern fn __wasm_bindgen_generated_Foo_get(me: u32) -&gt; i32 {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    wasm_bindgen::__rt::assert_not_null(me);
    let me = unsafe { &amp;*me };
    return me.borrow().get();
}

#[export_name = &quot;foo_set&quot;]
pub extern fn __wasm_bindgen_generated_Foo_set(me: u32, arg1: i32) {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    ::wasm_bindgen::__rt::assert_not_null(me);
    let me = unsafe { &amp;*me };
    me.borrow_mut().set(arg1);
}

#[no_mangle]
pub unsafe extern fn __wbindgen_foo_free(me: u32) {
    let me = me as *mut WasmRefCell&lt;Foo&gt;;
    wasm_bindgen::__rt::assert_not_null(me);
    (*me).borrow_mut(); // ensure no active borrows
    drop(Box::from_raw(me));
}
#}</code></pre></pre>
<p>As with before this is cleaned up from the actual output but it's the same idea
as to what's going on! Here we can see a shim for each function as well as a
shim for deallocating an instance of <code>Foo</code>. Recall that the only valid wasm
types today are numbers, so we're required to shoehorn all of <code>Foo</code> into a
<code>u32</code>, which is currently done via <code>Box</code> (like <code>std::unique_ptr</code> in C++).
Note, though, that there's an extra layer here, <code>WasmRefCell</code>. This type is the
same as <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> and can be mostly glossed over.</p>
<p>The purpose for this type, if you're interested though, is to uphold Rust's
guarantees about aliasing in a world where aliasing is rampant (JS).
Specifically the <code>&amp;Foo</code> type means that there can be as much alaising as you'd
like, but crucially <code>&amp;mut Foo</code> means that it is the sole pointer to the data
(no other <code>&amp;Foo</code> to the same instance exists). The <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> type in libstd
is a way of dynamically enforcing this at runtime (as opposed to compile time
where it usually happens). Baking in <code>WasmRefCell</code> is the same idea here,
adding runtime checks for aliasing which are typically happening at compile
time. This is currently a Rust-specific feature which isn't actually in the
<code>wasm-bindgen</code> tool itself, it's just in the Rust-generated code (aka the
<code>#[wasm_bindgen]</code> attribute).</p>
<a class="header" href="print.html#customizing-import-behavior" id="customizing-import-behavior"><h1>Customizing import behavior</h1></a>
<p>The <code>#[wasm_bindgen]</code> macro supports a good amount of configuration for
controlling precisely how exports are exported and what they generate in JS.
This section is intended to hopefully be an exhaustive reference of the
possibilities!</p>
<ul>
<li>
<p><code>readonly</code> - when attached to a <code>pub</code> struct field this indicates that it's
readonly from JS and a setter will not be generated.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Foo {
    pub first: u32,
    #[wasm_bindgen(readonly)]
    pub second: u32,
}
#}</code></pre></pre>
<p>Here the <code>first</code> field will be both readable and writable from JS, but the
<code>second</code> field will be a <code>readonly</code> field in JS where the setter isn't
implemented and attempting to set it will throw an exception.</p>
</li>
<li>
<p><code>constructor</code> - when attached to a Rust &quot;constructor&quot; it will make the
generated JS bindings callable as <code>new Foo()</code>, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Foo {
    contents: u32,
}

#[wasm_bindgen]
impl Foo {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; Foo {
        Foo { contents: 0 }
    }

    pub fn get_contents(&amp;self) -&gt; u32 {
        self.contents
    }
}
#}</code></pre></pre>
<p>Here this can be used in JS as:</p>
<pre><code class="language-js">import { Foo } from './my_module';

const f = new Foo();
console.log(f.get_contents());
</code></pre>
</li>
</ul>
<a class="header" href="print.html#importing-a-function-from-js" id="importing-a-function-from-js"><h1>Importing a function from JS</h1></a>
<p>Now that we've exported some rich functionality to JS it's also time to import
some! The goal here is to basically implement JS <code>import</code> statements in Rust,
with fancy types and all.</p>
<p>First up, let's say we invert the function above and instead want to generate
greetings in JS but call it from Rust. We might have, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;./greet&quot;)]
extern {
    fn greet(a: &amp;str) -&gt; String;
}

fn other_code() {
    let greeting = greet(&quot;foo&quot;);
    // ...
}
#}</code></pre></pre>
<p>The basic idea of imports is the same as exports in that we'll have shims in
both JS and Rust doing the necessary translation. Let's first see the JS shim in
action:</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

import { greet } from './greet';

// ...

export function __wbg_f_greet(ptr0, len0, wasmretptr) {
  const [retptr, retlen] = passStringToWasm(greet(getStringFromWasm(ptr0, len0)));
  (new Uint32Array(wasm.memory.buffer))[wasmretptr / 4] = retlen;
  return retptr;
}
</code></pre>
<p>The <code>getStringFromWasm</code> and <code>passStringToWasm</code> are the same as we saw before,
and like with <code>__wbindgen_object_drop_ref</code> far above we've got this weird export
from our module now! The <code>__wbg_f_greet</code> function is what's generated by
<code>wasm-bindgen</code> to actually get imported in the <code>foo.wasm</code> module.</p>
<p>The generated <code>foo.js</code> we see imports from the <code>./greet</code> module with the <code>greet</code>
name (was the function import in Rust said) and then the <code>__wbg_f_greet</code>
function is shimming that import.</p>
<p>There's some tricky ABI business going on here so let's take a look at the
generated Rust as well. Like before this is simplified from what's actually
generated.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern fn greet(a: &amp;str) -&gt; String {
    extern {
        fn __wbg_f_greet(a_ptr: *const u8, a_len: usize, ret_len: *mut usize) -&gt; *mut u8;
    }
    unsafe {
        let a_ptr = a.as_ptr();
        let a_len = a.len();
        let mut __ret_strlen = 0;
        let mut __ret_strlen_ptr = &amp;mut __ret_strlen as *mut usize;
        let _ret = __wbg_f_greet(a_ptr, a_len, __ret_strlen_ptr);
        String::from_utf8_unchecked(
            Vec::from_raw_parts(_ret, __ret_strlen, __ret_strlen)
        )
    }
}
#}</code></pre></pre>
<p>Here we can see that the <code>greet</code> function was generated but it's largely just a
shim around the <code>__wbg_f_greet</code> function that we're calling. The ptr/len pair
for the argument is passed as two arguments and for the return value we're
receiving one value (the length) indirectly while directly receiving the
returned pointer.</p>
<a class="header" href="print.html#importing-a-class-from-js" id="importing-a-class-from-js"><h1>Importing a class from JS</h1></a>
<p>Just like with functions after we've started exporting we'll also want to
import! Now that we've exported a <code>class</code> to JS we'll want to also be able to
import classes in Rust as well to invoke methods and such. Since JS classes are
in general just JS objects the bindings here will look pretty similar to the JS
object bindings describe above.</p>
<p>As usual though, let's dive into an example!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;./bar&quot;)]
extern {
    type Bar;

    #[wasm_bindgen(constructor)]
    fn new(arg: i32) -&gt; Bar;

    #[wasm_bindgen(js_namespace = Bar)]
    fn another_function() -&gt; i32;

    #[wasm_bindgen(method)]
    fn get(this: &amp;Bar) -&gt; i32;

    #[wasm_bindgen(method)]
    fn set(this: &amp;Bar, val: i32);

    #[wasm_bindgen(method, getter)]
    fn property(this: &amp;Bar) -&gt; i32;

    #[wasm_bindgen(method, setter)]
    fn set_property(this: &amp;Bar, val: i32);
}

fn run() {
    let bar = Bar::new(Bar::another_function());
    let x = bar.get();
    bar.set(x + 3);

    bar.set_property(bar.property() + 6);
}
#}</code></pre></pre>
<p>Unlike our previous imports, this one's a bit more chatty! Remember that one of
the goals of <code>wasm-bindgen</code> is to use native Rust syntax wherever possible, so
this is mostly intended to use the <code>#[wasm_bindgen]</code> attribute to interpret
what's written down in Rust. Now there's a few attribute annotations here, so
let's go through one-by-one:</p>
<ul>
<li><code>#[wasm_bindgen(module = &quot;./bar&quot;)]</code> - seen before with imports this is declare
where all the subsequent functionality is imported form. For example the <code>Bar</code>
type is going to be imported from the <code>./bar</code> module.</li>
<li><code>type Bar</code> - this is a declaration of JS class as a new type in Rust. This
means that a new type <code>Bar</code> is generated which is &quot;opaque&quot; but is represented
as internally containing a <code>JsValue</code>. We'll see more on this later.</li>
<li><code>#[wasm_bindgen(constructor)]</code> - this indicates that the binding's name isn't
actually used in JS but rather translates to <code>new Bar()</code>. The return value of
this function must be a bare type, like <code>Bar</code>.</li>
<li><code>#[wasm_bindgen(js_namespace = Bar)]</code> - this attribute indicates that the
function declaration is namespaced through the <code>Bar</code> class in JS.</li>
<li><code>#[wasm_bindgen(static_method_of = SomeJsClass)]</code> - this attribute is similar
to <code>js_namespace</code>, but instead of producing a free function, produces a static
method of <code>SomeJsClass</code>.</li>
<li><code>#[wasm_bindgen(method)]</code> - and finally, this attribute indicates that a
method call is going to happen. The first argument must be a JS struct, like
<code>Bar</code>, and the call in JS looks like <code>Bar.prototype.set.call(...)</code>.</li>
</ul>
<p>With all that in mind, let's take a look at the JS generated.</p>
<pre><code class="language-js">import * as wasm from './foo_bg';

import { Bar } from './bar';

// other support functions omitted...

export function __wbg_s_Bar_new() {
  return addHeapObject(new Bar());
}

const another_function_shim = Bar.another_function;
export function __wbg_s_Bar_another_function() {
  return another_function_shim();
}

const get_shim = Bar.prototype.get;
export function __wbg_s_Bar_get(ptr) {
  return shim.call(getObject(ptr));
}

const set_shim = Bar.prototype.set;
export function __wbg_s_Bar_set(ptr, arg0) {
  set_shim.call(getObject(ptr), arg0)
}

const property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').get;
export function __wbg_s_Bar_property(ptr) {
  return property_shim.call(getObject(ptr));
}

const set_property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').set;
export function __wbg_s_Bar_set_property(ptr, arg0) {
  set_property_shim.call(getObject(ptr), arg0)
}
</code></pre>
<p>Like when importing functions from JS we can see a bunch of shims are generated
for all the relevant functions. The <code>new</code> static function has the
<code>#[wasm_bindgen(constructor)]</code> attribute which means that instead of any
particular method it should actually invoke the <code>new</code> constructor instead (as
we see here). The static function <code>another_function</code>, however, is dispatched as
<code>Bar.another_function</code>.</p>
<p>The <code>get</code> and <code>set</code> functions are methods so they go through <code>Bar.prototype</code>,
and otherwise their first argument is implicitly the JS object itself which is
loaded through <code>getObject</code> like we saw earlier.</p>
<p>Some real meat starts to show up though on the Rust side of things, so let's
take a look:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Bar {
    obj: JsValue,
}

impl Bar {
    fn new() -&gt; Bar {
        extern {
            fn __wbg_s_Bar_new() -&gt; u32;
        }
        unsafe {
            let ret = __wbg_s_Bar_new();
            Bar { obj: JsValue::__from_idx(ret) }
        }
    }

    fn another_function() -&gt; i32 {
        extern {
            fn __wbg_s_Bar_another_function() -&gt; i32;
        }
        unsafe {
            __wbg_s_Bar_another_function()
        }
    }

    fn get(&amp;self) -&gt; i32 {
        extern {
            fn __wbg_s_Bar_get(ptr: u32) -&gt; i32;
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            let ret = __wbg_s_Bar_get(ptr);
            return ret
        }
    }

    fn set(&amp;self, val: i32) {
        extern {
            fn __wbg_s_Bar_set(ptr: u32, val: i32);
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            __wbg_s_Bar_set(ptr, val);
        }
    }

    fn property(&amp;self) -&gt; i32 {
        extern {
            fn __wbg_s_Bar_property(ptr: u32) -&gt; i32;
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            let ret = __wbg_s_Bar_property(ptr);
            return ret
        }
    }

    fn set_property(&amp;self, val: i32) {
        extern {
            fn __wbg_s_Bar_set_property(ptr: u32, val: i32);
        }
        unsafe {
            let ptr = self.obj.__get_idx();
            __wbg_s_Bar_set_property(ptr, val);
        }
    }
}

impl WasmBoundary for Bar {
    // ...
}

impl ToRefWasmBoundary for Bar {
    // ...
}
#}</code></pre></pre>
<p>In Rust we're seeing that a new type, <code>Bar</code>, is generated for this import of a
class. The type <code>Bar</code> internally contains a <code>JsValue</code> as an instance of <code>Bar</code>
is meant to represent a JS object stored in our module's stack/slab. This then
works mostly the same way that we saw JS objects work in the beginning.</p>
<p>When calling <code>Bar::new</code> we'll get an index back which is wrapped up in <code>Bar</code>
(which is itself just a <code>u32</code> in memory when stripped down). Each function then
passes the index as the first argument and otherwise forwards everything along
in Rust.</p>
<a class="header" href="print.html#customizing-import-behavior-1" id="customizing-import-behavior-1"><h1>Customizing import behavior</h1></a>
<p>The <code>#[wasm_bindgen]</code> macro supports a good amount of configuration for
controlling precisely how imports are imported and what they map to in JS. This
section is intended to hopefully be an exhaustive reference of the
possibilities!</p>
<ul>
<li>
<p><code>module</code> and <code>version</code> - we've seen <code>module</code> so far indicating where we can
import items from but <code>version</code> is also allowed:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen(module = &quot;moment&quot;, version = &quot;^2.0.0&quot;)]
extern {
    type Moment;
    fn moment() -&gt; Moment;
    #[wasm_bindgen(method)]
    fn format(this: &amp;Moment) -&gt; String;
}
#}</code></pre></pre>
<p>The <code>module</code> key is used to configure the module that each item is imported
from. The <code>version</code> key does not affect the generated wasm itself but rather
it's an informative directive for tools like <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a>. Tools like wasm-pack
will generate a <code>package.json</code> for you and the <code>version</code> listed here, when
<code>module</code> is also an NPM package, will correspond to what to write down in
<code>package.json</code>.</p>
<p>In other words the usage of <code>module</code> as the name of an NPM package and
<code>version</code> as the version requirement allows you to, inline in Rust, depend on
the NPM ecosystem and import functionality from those packages. When bundled
with a tool like <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a> everything will automatically get wired up with
bundlers and you should be good to go!</p>
<p>Note that the <code>version</code> is <em>required</em> if <code>module</code> doesn't start with <code>./</code>. If
<code>module</code> starts with <code>./</code> then it is an error to provide a version.</p>
</li>
</ul>
<ul>
<li>
<p><code>catch</code> - this attribute allows catching a JS exception. This can be attached
to any imported function and the function must return a <code>Result</code> where the
<code>Err</code> payload is a <code>JsValue</code>, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(catch)]
    fn foo() -&gt; Result&lt;(), JsValue&gt;;
}
#}</code></pre></pre>
<p>If the imported function throws an exception then <code>Err</code> will be returned with
the exception that was raised, and otherwise <code>Ok</code> is returned with the result
of the function.</p>
<p>By default <code>wasm-bindgen</code> will take no action when wasm calls a JS function
which ends up throwing an exception. The wasm spec right now doesn't support
stack unwinding and as a result Rust code <strong>will not execute destructors</strong>.
This can unfortunately cause memory leaks in Rust right now, but as soon as
wasm implements catching exceptions we'll be sure to add support as well!</p>
</li>
<li>
<p><code>constructor</code> - this is used to indicate that the function being bound should
actually translate to a <code>new</code> constructor in JS. The final argument must be a
type that's imported from JS, and it's what'll get used in JS:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(constructor)]
    fn new() -&gt; Foo;
}
#}</code></pre></pre>
<p>This will attach the <code>new</code> function to the <code>Foo</code> type (implied by
<code>constructor</code>) and in JS when this function is called it will be equivalent to
<code>new Foo()</code>.</p>
</li>
<li>
<p><code>method</code> - this is the gateway to adding methods to imported objects or
otherwise accessing properties on objects via methods and such. This should be
done for doing the equivalent of expressions like <code>foo.bar()</code> in JS.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(method)]
    fn work(this: &amp;Foo);
}
#}</code></pre></pre>
<p>The first argument of a <code>method</code> annotation must be a borrowed reference (not
mutable, shared) to the type that the method is attached to. In this case
we'll be able to call this method like <code>foo.work()</code> in JS (where <code>foo</code> has
type <code>Foo</code>).</p>
<p>In JS this invocation will correspond to accessing <code>Foo.prototype.work</code> and
then calling that when the import is called. Note that <code>method</code> by default
implies going through <code>prototype</code> to get a function pointer.</p>
</li>
<li>
<p><code>js_namespace</code> - this attribute indicates that the JS type is accessed through
a particular namespace. For example the <code>WebAssembly.Module</code> APIs are all
accessed through the <code>WebAssembly</code> namespace. The <code>js_namespace</code> can be
applied to any import and whenever the generated JS attempts to reference a
name (like a class or function name) it'll be accessed through this namespace.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}
#}</code></pre></pre>
<p>This is an example of how to bind <code>console.log(x)</code> in Rust. The <code>log</code> function
will be available in the Rust module and will be invoked as <code>console.log</code> in
JS.</p>
</li>
<li>
<p><code>getter</code> and <code>setter</code> - these two attributes can be combined with <code>method</code> to
indicate that this is a getter or setter method. A <code>getter</code>-tagged function by
default accesses the JS property with the same name as the getter function. A
<code>setter</code>'s function name is currently required to start with &quot;set_&quot; and the
property it accesses is the suffix after &quot;set_&quot;.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(method, getter)]
    fn property(this: &amp;Foo) -&gt; u32;
    #[wasm_bindgen(method, setter)]
    fn set_property(this: &amp;Foo, val: u32);
}
#}</code></pre></pre>
<p>Here we're importing the <code>Foo</code> type and defining the ability to access each
object's <code>property</code> property. The first function here is a getter and will be
available in Rust as <code>foo.property()</code>, and the latter is the setter which is
accessible as <code>foo.set_property(2)</code>. Note that both functions have a <code>this</code>
argument as they're tagged with <code>method</code>.</p>
<p>Finally, you can also pass an argument to the <code>getter</code> and <code>setter</code>
properties to configure what property is accessed. When the property is
explicitly specified then there is no restriction on the method name. For
example the below is equivalent to the above:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(method, getter = property)]
    fn assorted_method_name(this: &amp;Foo) -&gt; u32;
    #[wasm_bindgen(method, setter = &quot;property&quot;)]
    fn some_other_method_name(this: &amp;Foo, val: u32);
}
#}</code></pre></pre>
<p>Properties in JS are accessed through <code>Object.getOwnPropertyDescriptor</code>. Note
that this typically only works for class-like-defined properties which aren't
just attached properties on any old object. For accessing any old property on
an object we can use...</p>
</li>
<li>
<p><code>structural</code> - this is a flag to <code>method</code> annotations which indicates that the
method being accessed (or property with getters/setters) should be accessed in
a structural fashion. For example methods are <em>not</em> accessed through
<code>prototype</code> and properties are accessed on the object directly rather than
through <code>Object.getOwnPropertyDescriptor</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(method, structural)]
    fn bar(this: &amp;Foo);
    #[wasm_bindgen(method, getter, structural)]
    fn baz(this: &amp;Foo) -&gt; u32;
}
#}</code></pre></pre>
<p>The type here, <code>Foo</code>, is not required to exist in JS (it's not referenced).
Instead wasm-bindgen will generate shims that will access the passed in JS
value's <code>bar</code> property to or the <code>baz</code> property (depending on the function).</p>
</li>
<li>
<p><code>js_name = foo</code> - this can be used to bind to a different function in JS than
the identifier that's defined in Rust. For example you can also define
multiple signatures for a polymorphic function in JS as well:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    type Foo;
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_string(s: &amp;str);
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(n: u32);
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: u32, b: JsValue);
}
#}</code></pre></pre>
<p>All of these functions will call <code>console.log</code> in Rust, but each identifier
will have only one signature in Rust.</p>
</li>
</ul>
<a class="header" href="print.html#rust-type-conversions" id="rust-type-conversions"><h1>Rust Type conversions</h1></a>
<p>Previously we've been seeing mostly abridged versions of type conversions when
values enter Rust. Here we'll go into some more depth about how this is
implemented. There are two categories of traits for converting values, traits
for converting values from Rust to JS and traits for the other way around.</p>
<a class="header" href="print.html#from-rust-to-js" id="from-rust-to-js"><h3>From Rust to JS</h3></a>
<p>First up let's take a look at going from Rust to JS:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait IntoWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    fn into_abi(self, extra: &amp;mut Stack) -&gt; Self::Abi;
}
#}</code></pre></pre>
<p>And that's it! This is actually the only trait needed currently for translating
a Rust value to a JS one. There's a few points here:</p>
<ul>
<li>We'll get to <code>WasmDescribe</code> later in this section</li>
<li>The associated type <code>Abi</code> is what will actually be generated as an argument to
the wasm export. The bound <code>WasmAbi</code> is only implemented for types like <code>u32</code>
and <code>f64</code>, those which can be placed on the boundary and transmitted
losslessly.</li>
<li>And finally we have the <code>into_abi</code> function, returning the <code>Abi</code> associated
type which will be actually passed to JS. There's also this <code>Stack</code> parameter,
however. Not all Rust values can be communicated in 32 bits to the <code>Stack</code>
parameter allows transmitting more data, explained in a moment.</li>
</ul>
<p>This trait is implemented for all types that can be converted to JS and is
unconditionally used during codegen. For example you'll often see <code>IntoWasmAbi for Foo</code> but also <code>IntoWasmAbi for &amp;'a Foo</code>.</p>
<p>The <code>IntoWasmAbi</code> trait is used in two locations. First it's used to convert
return values of Rust exported functions to JS. Second it's used to convert the
Rust arguments of JS functions imported to Rust.</p>
<a class="header" href="print.html#from-js-to-rust" id="from-js-to-rust"><h3>From JS to Rust</h3></a>
<p>Unfortunately the opposite direction from above, going from JS to Rust, is a bit
more complicated. Here we've got three traits:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait FromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    unsafe fn from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self;
}

pub trait RefFromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    type Anchor: Deref&lt;Target=Self&gt;;
    unsafe fn ref_from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self::Anchor;
}

pub trait RefMutFromWasmAbi: WasmDescribe {
    type Abi: WasmAbi;
    type Anchor: DerefMut&lt;Target=Self&gt;;
    unsafe fn ref_mut_from_abi(js: Self::Abi, extra: &amp;mut Stack) -&gt; Self::Anchor;
}
#}</code></pre></pre>
<p>The <code>FromWasmAbi</code> is relatively straightforward, basically the opposite of
<code>IntoWasmAbi</code>. It takes the ABI argument (typically the same as
<code>IntoWasmAbi::Abi</code>) and then the auxiliary stack to produce an instance of
<code>Self</code>. This trait is implemented primarily for types that <em>don't</em> have internal
lifetimes or are references.</p>
<p>The latter two traits here are mostly the same, and are intended for generating
references (both shared and mutable references). They look almost the same as
<code>FromWasmAbi</code> except that they return an <code>Anchor</code> type which implements a
<code>Deref</code> trait rather than <code>Self</code>.</p>
<p>The <code>Ref*</code> traits allow having arguments in functions that are references rather
than bare types, for example <code>&amp;str</code>, <code>&amp;JsValue</code>, or <code>&amp;[u8]</code>. The <code>Anchor</code> here
is required to ensure that the lifetimes don't persist beyond one function call
and remain anonymous.</p>
<p>The <code>From*</code> family of traits are used for converting the Rust arguments in Rust
exported functions to JS. They are also used for the return value in JS
functions imported into Rust.</p>
<a class="header" href="print.html#global-stack" id="global-stack"><h3>Global stack</h3></a>
<p>Mentioned above not all Rust types will fit within 32 bits. While we can
communicate an <code>f64</code> we don't necessarily have the ability to use all the bits.
Types like <code>&amp;str</code> need to communicate two items, a pointer and a length (64
bits). Other types like <code>&amp;Closure&lt;Fn()&gt;</code> have even more information to
transmit.</p>
<p>As a result we need a method of communicating more data through the signatures
of functions. While we could add more arguments this is somewhat difficult to do
in the world of closures where code generation isn't quite as dynamic as a
procedural macro. Consequently a &quot;global stack&quot; is used to transmit extra
data for a function call.</p>
<p>The global stack is a fixed-sized static allocation in the wasm module. This
stack is temporary scratch space for any one function call from either JS to
Rust or Rust ot JS. Both Rust and the JS shim generated have pointers to this
global stack and will read/write information from it.</p>
<p>Using this scheme whenever we want to pass <code>&amp;str</code> from JS to Rust we can pass
the pointer as the actual ABI argument and the length is then placed in the next
spot on the global stack.</p>
<p>The <code>Stack</code> argument to the conversion traits above looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Stack {
    fn push(&amp;mut self, bits: u32);
    fn pop(&amp;mut self) -&gt; u32;
}
#}</code></pre></pre>
<p>A trait is used here to facilitate testing but typically the calls don't end up
being virtually dispatched at runtime.</p>
<a class="header" href="print.html#communicating-types-to-wasm-bindgen" id="communicating-types-to-wasm-bindgen"><h1>Communicating types to <code>wasm-bindgen</code></h1></a>
<p>The last aspect to talk about when converting Rust/JS types amongst one another
is how this information is actually communicated. The <code>#[wasm_bindgen]</code> macro is
running over the syntactical (unresolved) structure of the Rust code and is then
responsible for generating information that <code>wasm-bindgen</code> the CLI tool later
reads.</p>
<p>To accomplish this a slightly unconventional approach is taken. Static
information about the structure of the Rust code is serialized via JSON
(currently) to a custom section of the wasm executable. Other information, like
what the types actually are, unfortunately isn't known until later in the
compiler due to things like associated type projections and typedefs. It also
turns out that we want to convey &quot;rich&quot; types like <code>FnMut(String, Foo, &amp;JsValue)</code> to the <code>wasm-bindgen</code> CLI, and handling all this is pretty tricky!</p>
<p>To solve this issue the <code>#[wasm_bindgen]</code> macro generates <strong>executable
functions</strong> which &quot;describe the type signature of an import or export&quot;. These
executable functions are what the <code>WasmDescribe</code> trait is all about:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait WasmDescribe {
    fn describe();
}
#}</code></pre></pre>
<p>While deceptively simple this trait is actually quite important. When you write,
an export like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
fn greet(a: &amp;str) {
    // ...
}
#}</code></pre></pre>
<p>In addition to the shims we talked about above which JS generates the macro
<em>also</em> generates something like:</p>
<pre><code>#[no_mangle]
pub extern fn __wbindgen_describe_greet() {
    &lt;Fn(&amp;str)&gt;::describe();
}
</code></pre>
<p>Or in other words it generates invocations of <code>describe</code> functions. In doing so
the <code>__wbindgen_describe_greet</code> shim is a programmatic description of the type
layouts of an import/export. These are then executed when <code>wasm-bindgen</code> runs!
These executions rely on an import called <code>__wbindgen_describe</code> which passes one
<code>u32</code> to the host, and when called multiple times gives a <code>Vec&lt;u32&gt;</code>
effectively. This <code>Vec&lt;u32&gt;</code> can then be reparsed into an <code>enum Descriptor</code>
which fully describes a type.</p>
<p>All in all this is a bit roundabout but shouldn't have any impact on the
generated code or runtime at all. All these descriptor functions are pruned from
the emitted wasm file.</p>
<a class="header" href="print.html#web-sys" id="web-sys"><h1><code>web-sys</code></h1></a>
<p>The <code>web-sys</code> crate provides raw bindings to all of the Web's APIs, and its
source lives at <code>wasm-bindgen/crates/web-sys</code>.</p>
<p>The <code>web-sys</code> crate is <strong>entirely</strong> mechanically generated inside <code>build.rs</code>
using <code>wasm-bindgen</code>'s WebIDL frontend and the WebIDL interface definitions for
Web APIs.</p>
<a class="header" href="print.html#web-sys-overview" id="web-sys-overview"><h1><code>web-sys</code> Overview</h1></a>
<p>The <code>web-sys</code> crate has this file and directory layout:</p>
<pre><code class="language-text">.
├── build.rs
├── Cargo.toml
├── README.md
├── src
│   └── lib.rs
└── webidls
    ├── available
    │   └── ...
    └── enabled
        └── ...
</code></pre>
<a class="header" href="print.html#webidlsavailablewebidl" id="webidlsavailablewebidl"><h3><code>webidls/available/*.webidl</code></h3></a>
<p>These are all the different WebIDL definitions we intend to support, but don't
yet. At the time of writing, these are the majority of <code>.webidl</code>s.</p>
<a class="header" href="print.html#webidlsenabledwebidl" id="webidlsenabledwebidl"><h3><code>webidls/enabled/*.webidl</code></h3></a>
<p>These are the WebIDL interfaces that we will actually generate bindings for (or
at least bindings for <em>some</em> of the things defined in these files).</p>
<a class="header" href="print.html#buildrs" id="buildrs"><h3><code>build.rs</code></h3></a>
<p>The <code>build.rs</code> invokes <code>wasm-bindgen</code>'s WebIDL frontend on all the WebIDL files
in <code>webidls/enabled</code>. It writes the resulting bindings into the cargo build's
out directory.</p>
<a class="header" href="print.html#srclibrs" id="srclibrs"><h3><code>src/lib.rs</code></h3></a>
<p>The only thing <code>src/lib.rs</code> does is include the bindings generated at compile
time in <code>build.rs</code>. Here is the whole <code>src/lib.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(wasm_custom_section, wasm_import_module)]

#fn main() {
extern crate wasm_bindgen;

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/bindings.rs&quot;));

#}</code></pre></pre>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<p>You can test the <code>web-sys</code> crate by running <code>cargo test</code> within the
<code>crates/web-sys</code> directory in the <code>wasm-bindgen</code> repository:</p>
<pre><code class="language-sh">cd wasm-bindgen/crates/web-sys
cargo test
</code></pre>
<p>These tests all use a headless Firefox browser. See the <a href="../contributing.html#headless-browser-tests"><em>Headless Browser
Tests</em> section for details on setup and
configuration.</a></p>
<a class="header" href="print.html#grouping-tests" id="grouping-tests"><h2>Grouping Tests</h2></a>
<p>Because headless tests can have significant setup and tear down overheads, try
and group tests together. Instead of having a different <code>#[test]</code> for every
method on some interface, have a single <code>#[test]</code> for the interface and all of
its methods. This will keep the test suite running fast, resulting in better
developer ergonomics and CI turn around times. Thanks!</p>
<a class="header" href="print.html#logging" id="logging"><h1>Logging</h1></a>
<p>The <code>wasm_bindgen_webidl</code> crate (used by <code>web-sys</code>'s <code>build.rs</code>) uses
<a href="https://crates.io/crates/env_logger"><code>env_logger</code></a> for logging, which can be enabled by setting the
<code>RUST_LOG=wasm_bindgen_webidl</code> environment variable while building the <code>web-sys</code>
crate.</p>
<p>Make sure to enable &quot;very verbose&quot; output during <code>cargo build</code> to see these logs
within <code>web-sys</code>'s build script output.</p>
<pre><code class="language-sh">cd crates/web-sys
RUST_LOG=wasm_bindgen_webidl cargo build -vv
</code></pre>
<p>If <code>wasm_bindgen_webidl</code> encounters WebIDL constructs that it doesn't know how
to translate into <code>wasm-bindgen</code> AST items, it will emit warn-level logs.</p>
<pre><code>WARN 2018-07-06T18:21:49Z: wasm_bindgen_webidl: Unsupported WebIDL interface: ...
</code></pre>
<a class="header" href="print.html#supporting-more-web-apis-in-web-sys" id="supporting-more-web-apis-in-web-sys"><h1>Supporting More Web APIs in <code>web-sys</code></h1></a>
<ol>
<li>
<p><input type="checkbox"/> Ensure that the <code>.webidl</code> file describing the
interface exists somewhere within the <code>crates/web-sys/webidls/enabled</code>
directory.</p>
<p>First, check to see whether we have the WebIDL definition file for
your API:</p>
<pre><code class="language-sh">grep -rn MyWebApi crates/web-sys/webidls
</code></pre>
<ul>
<li>
<p>If your interface is defined in a <code>.webidl</code> file that is inside the
<code>crates/web-sys/webidls/enabled</code> directory, skip to step (3).</p>
</li>
<li>
<p>If your interface isn't defined in any file yet, find the WebIDL definition
in the relevant standard and add it as a new <code>.webidl</code> file in
<code>crates/web-sys/webidls/enabled</code>. Make sure that it is a standard Web API!
We don't want to add non-standard APIs to this crate.</p>
</li>
<li>
<p>If your interface is defined in a <code>.webidl</code> file within the
<code>crates/web-sys/webidls/available</code> directory, you need to move it into
<code>crates/web-sys/webidls/enabled</code>:</p>
<pre><code class="language-sh">cd crates/web-sys
git mv webidls/available/MyWebApi.webidl webidls/enabled/MyWebApi.webidl
</code></pre>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Verify that the <code>web-sys</code> crate still builds and
that its tests still pass with the new <code>.webidl</code> file enabled:</p>
<pre><code class="language-sh">cd crates/web-sys
cargo build
cargo test
</code></pre>
</li>
<li>
<p><input type="checkbox"/> Verify that bindings are being generated for your new
API by generating the documentation and searching for the new API in it:</p>
<pre><code class="language-sh">cd crates/web-sys
cargo doc --open
# search for the new API in the opened docs
</code></pre>
<ul>
<li><input type="checkbox"/> If the new API is <strong>not</strong> showing up in the docs,
rebuild the <code>web-sys</code> crate <a href="/web-sys/logging.html">with logging enabled</a>
and look for warning messages that mention your new API. Figure out why
bindings weren't generated and then add support to <code>wasm_bindgen_webidl</code> for
whatever is needed to generate your API's bindings.</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Add a simple test for your new API to
<code>crates/web-sys/tests/all/</code>. See the <a href="/web-sys/testing.html"><code>web-sys</code> testing
documentation</a> for details.</p>
</li>
<li>
<p><input type="checkbox"/> Send a pull request! 😊</p>
</li>
</ol>
<a class="header" href="print.html#team" id="team"><h1>Team</h1></a>
<p><code>wasm-bindgen</code> follows the <a href="https://github.com/rustwasm/team/blob/master/GOVERNANCE.md#repositories"><code>rustwasm</code> organization's governance described
here</a>:</p>
<ul>
<li>
<p>All pull requests (including those made by a team member) must be approved by
at least one other team member.</p>
</li>
<li>
<p>Larger, more nuanced decisions about design, architecture, breaking changes,
trade offs, etc are made by team consensus.</p>
</li>
</ul>
<a class="header" href="print.html#members" id="members"><h2>Members</h2></a>
<style>
img {
    max-width: 117px;
    max-height: 117px;
}
</style>
<table><thead><tr><th align="center"> <a href="https://github.com/alexcrichton"><img src="https://github.com/alexcrichton.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/fitzgen"><img src="https://github.com/fitzgen.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/spastorino"><img src="https://github.com/spastorino.png?size=117" alt="" /></a> </th><th align="center"> <a href="https://github.com/ohanar"><img src="https://github.com/ohanar.png?size=117" alt="" /></a> </th><th> <a href="https://github.com/jonathan-s"><img src="https://github.com/jonathan-s.png?size=117" alt="" /></a> </th></tr></thead><tbody>
<tr><td align="center"> <a href="https://github.com/alexcrichton"><code>alexcrichton</code></a> </td><td align="center"> <a href="https://github.com/fitzgen"><code>fitzgen</code></a> </td><td align="center"> <a href="https://github.com/spastorino"><code>spastorino</code></a> </td><td align="center"> <a href="https://github.com/ohanar"><code>ohanar</code></a> </td><td> <a href="https://github.com/jonathan-s"><code>jonathan-s</code></a> </td></tr>
<tr><td align="center"> <a href="https://github.com/sendilkumarn"><img src="https://github.com/sendilkumarn.png?size=117" alt="" /></a> </td><td align="center"> <a href="https://github.com/belfz"><img src="https://github.com/belfz.png?size=117" alt="" /></a> </td><td align="center"> </td><td align="center"> </td><td> </td></tr>
<tr><td align="center"> <a href="https://github.com/sendilkumarn"><code>sendilkumarn</code></a> </td><td align="center"> <a href="https://github.com/belfz"><code>belfz</code></a> </td><td align="center"> </td><td align="center"> </td><td> </td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
